"""
Decision schemas (Pydantic v2).

What this file does
-------------------
This module defines the data models for **human-in-the-loop decisions**.

In pharma/biotech workflows, it's common (and important) to separate:
- what the system recommended (the "machine suggestion")
- what a human ultimately decided (the "final decision")

Why this matters (enterprise / regulated mindset)
-------------------------------------------------
When decisions are reviewed later (internal QC, vendor oversight, inspections),
you need to answer:
- Who approved/overrode the recommendation?
- When did they do it?
- What final action was taken?
- If they overrode it, **why**?

This is exactly the kind of "auditability" signal that makes systems production-ready.
"""

from __future__ import annotations

from datetime import datetime
from enum import Enum
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, model_validator

from agent.schemas.recommendation import Action


class DecisionType(str, Enum):
    """
    The type of human decision applied to an agent recommendation.

    - APPROVE: the human agrees with the recommendation as-is
    - OVERRIDE: the human disagrees and chooses a different action (reason required)
    - EDIT: the human keeps the action but edits the text/message/rationale
    """

    APPROVE = "APPROVE"
    OVERRIDE = "OVERRIDE"
    EDIT = "EDIT"


class DecisionCreate(BaseModel):
    """
    Input model for recording a human decision.

    Why have a separate "Create" model?
    - In APIs, it's common that clients submit only the decision content.
    - The system then adds IDs/timestamps when storing the decision.

    You would typically use this model as the request body for an endpoint like:
    POST /issues/{issue_id}/decision
    """

    # In this MVP, we require decisions to be tied to a specific agent run.
    # That makes review auditable: "this decision was about that specific recommendation".
    run_id: UUID = Field(
        ...,
        description="Agent run ID that this decision is responding to.",
    )

    # Field name matches the API spec: decision_type (APPROVE/OVERRIDE/EDIT)
    decision_type: DecisionType = Field(
        ...,
        description="Whether the recommendation was approved, overridden, or edited.",
    )

    # We reuse the Action enum from the recommendation schema so actions stay consistent.
    final_action: Action = Field(
        ...,
        description=(
            "Final action chosen by the human reviewer (may differ from agent recommendation)."
        ),
    )

    # In many workflows the system drafts a message (e.g., site query).
    # The human can accept it, edit it, or replace it entirely.
    final_text: str = Field(
        ...,
        description="Final text after review (e.g., site query draft or stakeholder summary).",
    )

    reviewer: str = Field(
        ...,
        description="Identifier for the reviewer (e.g., username, initials, or role).",
    )

    # "reason" is required when the reviewer overrides the recommendation.
    # We'll enforce that rule using a model-level validator below.
    reason: str | None = Field(
        default=None,
        description=(
            "Required when decision_type is OVERRIDE. Explains why the recommendation was changed."
        ),
    )

    # Timestamp is system-generated by default, but we keep it on the model for
    # audit trail purposes.
    timestamp: datetime = Field(
        default_factory=datetime.utcnow,
        description="UTC timestamp when the decision was recorded.",
    )

    @model_validator(mode="after")
    def _require_reason_when_overridden(self) -> "DecisionCreate":
        """
        Cross-field validation.

        Pydantic field validation (like type checks) happens per-field.
        Sometimes you need rules that depend on *multiple* fields.

        Here we enforce a common enterprise rule:
        - If the decision is OVERRIDDEN, a reason must be provided.
        """

        if self.decision_type == DecisionType.OVERRIDE and not (
            self.reason and self.reason.strip()
        ):
            raise ValueError("reason is required when decision_type is OVERRIDE")
        return self


class Decision(BaseModel):
    """
    Stored decision model.

    This is the form you would store in a database and return from the API.
    It includes a system-generated decision_id and the issue_id it relates to.
    """

    decision_id: UUID = Field(
        default_factory=uuid4,
        description="Unique identifier for this decision (generated by the system).",
    )
    issue_id: UUID = Field(..., description="Issue ID this decision applies to.")

    # We embed the same fields as DecisionCreate so Decision is a complete record.
    run_id: UUID = Field(
        ...,
        description="Agent run ID that this decision is responding to.",
    )
    decision_type: DecisionType = Field(
        ...,
        description="Whether the recommendation was approved, overridden, or edited.",
    )
    final_action: Action = Field(..., description="Final action chosen by the human reviewer.")
    final_text: str = Field(
        ...,
        description="Final text after review (e.g., query draft).",
    )
    reviewer: str = Field(..., description="Identifier for the reviewer.")
    reason: str | None = Field(
        default=None,
        description=(
            "Required when decision_type is OVERRIDE. Explains why the recommendation was changed."
        ),
    )
    timestamp: datetime = Field(
        default_factory=datetime.utcnow,
        description="UTC timestamp when the decision was recorded.",
    )

    @model_validator(mode="after")
    def _require_reason_when_overridden(self) -> "Decision":
        """Same override rule as DecisionCreate, enforced on stored records too."""

        if self.decision_type == DecisionType.OVERRIDE and not (
            self.reason and self.reason.strip()
        ):
            raise ValueError("reason is required when decision_type is OVERRIDE")
        return self
